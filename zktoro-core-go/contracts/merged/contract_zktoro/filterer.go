// Code generated by go-merge-types. DO NOT EDIT.

package contract_zktoro

import (
	import_fmt "fmt"
	import_sync "sync"

	zktoro020 "zktoro/zktoro-core-go/contracts/generated/contract_zktoro_0_2_0"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"
)

// ZktoroFilterer is a new type which can multiplex calls to different implementation types.
type ZktoroFilterer struct {
	typ0 *zktoro020.ZktoroFilterer

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewZktoroFilterer creates a new merged type.
func NewZktoroFilterer(address common.Address, filterer bind.ContractFilterer) (*ZktoroFilterer, error) {
	var (
		mergedType ZktoroFilterer
		err        error
	)
	mergedType.currTag = "0.2.0"

	mergedType.typ0, err = zktoro020.NewZktoroFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize zktoro020.ZktoroFilterer: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForZktoroFilterer tells if given tag is a known tag.
func IsKnownTagForZktoroFilterer(tag string) bool {

	if tag == "0.2.0" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ZktoroFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForZktoroFilterer(tag) {
		tag = "0.2.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ZktoroFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ZktoroFilterer) Safe() {
	merged.unsafe = false
}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *zktoro020.ZktoroAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroAdminChanged is a merged return type.
type ZktoroAdminChanged struct {
	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log
}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseAdminChanged(log types.Log) (retVal *ZktoroAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroAdminChanged{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterApproval multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (retVal *zktoro020.ZktoroApprovalIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterApproval(opts, owner, spender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterApproval not implemented (tag=%s)", merged.currTag)
	return
}

// WatchApproval multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroApproval, owner []common.Address, spender []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchApproval(opts, sink, owner, spender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchApproval not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroApproval is a merged return type.
type ZktoroApproval struct {
	Owner common.Address

	Spender common.Address

	Value *big.Int

	Raw types.Log
}

// ParseApproval multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseApproval(log types.Log) (retVal *ZktoroApproval, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroApproval{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseApproval(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Owner = val.Owner

		retVal.Spender = val.Spender

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseApproval not implemented (tag=%s)", merged.currTag)
	return
}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *zktoro020.ZktoroBeaconUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroBeaconUpgraded, beacon []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroBeaconUpgraded is a merged return type.
type ZktoroBeaconUpgraded struct {
	Beacon common.Address

	Raw types.Log
}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseBeaconUpgraded(log types.Log) (retVal *ZktoroBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroBeaconUpgraded{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDelegateChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterDelegateChanged(opts *bind.FilterOpts, delegator []common.Address, fromDelegate []common.Address, toDelegate []common.Address) (retVal *zktoro020.ZktoroDelegateChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterDelegateChanged(opts, delegator, fromDelegate, toDelegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterDelegateChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDelegateChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchDelegateChanged(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroDelegateChanged, delegator []common.Address, fromDelegate []common.Address, toDelegate []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchDelegateChanged(opts, sink, delegator, fromDelegate, toDelegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchDelegateChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroDelegateChanged is a merged return type.
type ZktoroDelegateChanged struct {
	Delegator common.Address

	FromDelegate common.Address

	ToDelegate common.Address

	Raw types.Log
}

// ParseDelegateChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseDelegateChanged(log types.Log) (retVal *ZktoroDelegateChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroDelegateChanged{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseDelegateChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Delegator = val.Delegator

		retVal.FromDelegate = val.FromDelegate

		retVal.ToDelegate = val.ToDelegate

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseDelegateChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDelegateVotesChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterDelegateVotesChanged(opts *bind.FilterOpts, delegate []common.Address) (retVal *zktoro020.ZktoroDelegateVotesChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterDelegateVotesChanged(opts, delegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterDelegateVotesChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDelegateVotesChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchDelegateVotesChanged(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroDelegateVotesChanged, delegate []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchDelegateVotesChanged(opts, sink, delegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchDelegateVotesChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroDelegateVotesChanged is a merged return type.
type ZktoroDelegateVotesChanged struct {
	Delegate common.Address

	PreviousBalance *big.Int

	NewBalance *big.Int

	Raw types.Log
}

// ParseDelegateVotesChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseDelegateVotesChanged(log types.Log) (retVal *ZktoroDelegateVotesChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroDelegateVotesChanged{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseDelegateVotesChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Delegate = val.Delegate

		retVal.PreviousBalance = val.PreviousBalance

		retVal.NewBalance = val.NewBalance

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseDelegateVotesChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *zktoro020.ZktoroInitializedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// WatchInitialized multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroInitialized is a merged return type.
type ZktoroInitialized struct {
	Version uint8

	Raw types.Log
}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseInitialized(log types.Log) (retVal *ZktoroInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroInitialized{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRoleAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (retVal *zktoro020.ZktoroRoleAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterRoleAdminChanged(opts, role, previousAdminRole, newAdminRole)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterRoleAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRoleAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchRoleAdminChanged(opts, sink, role, previousAdminRole, newAdminRole)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchRoleAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroRoleAdminChanged is a merged return type.
type ZktoroRoleAdminChanged struct {
	Role [32]byte

	PreviousAdminRole [32]byte

	NewAdminRole [32]byte

	Raw types.Log
}

// ParseRoleAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseRoleAdminChanged(log types.Log) (retVal *ZktoroRoleAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroRoleAdminChanged{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseRoleAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Role = val.Role

		retVal.PreviousAdminRole = val.PreviousAdminRole

		retVal.NewAdminRole = val.NewAdminRole

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseRoleAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRoleGranted multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (retVal *zktoro020.ZktoroRoleGrantedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterRoleGranted(opts, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterRoleGranted not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRoleGranted multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchRoleGranted(opts, sink, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchRoleGranted not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroRoleGranted is a merged return type.
type ZktoroRoleGranted struct {
	Role [32]byte

	Account common.Address

	Sender common.Address

	Raw types.Log
}

// ParseRoleGranted multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseRoleGranted(log types.Log) (retVal *ZktoroRoleGranted, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroRoleGranted{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseRoleGranted(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Role = val.Role

		retVal.Account = val.Account

		retVal.Sender = val.Sender

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseRoleGranted not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRoleRevoked multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (retVal *zktoro020.ZktoroRoleRevokedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterRoleRevoked(opts, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterRoleRevoked not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRoleRevoked multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchRoleRevoked(opts, sink, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchRoleRevoked not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroRoleRevoked is a merged return type.
type ZktoroRoleRevoked struct {
	Role [32]byte

	Account common.Address

	Sender common.Address

	Raw types.Log
}

// ParseRoleRevoked multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseRoleRevoked(log types.Log) (retVal *ZktoroRoleRevoked, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroRoleRevoked{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseRoleRevoked(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Role = val.Role

		retVal.Account = val.Account

		retVal.Sender = val.Sender

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseRoleRevoked not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTransfer multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (retVal *zktoro020.ZktoroTransferIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterTransfer(opts, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterTransfer not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTransfer multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroTransfer, from []common.Address, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchTransfer(opts, sink, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchTransfer not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroTransfer is a merged return type.
type ZktoroTransfer struct {
	From common.Address

	To common.Address

	Value *big.Int

	Raw types.Log
}

// ParseTransfer multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseTransfer(log types.Log) (retVal *ZktoroTransfer, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroTransfer{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseTransfer(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.From = val.From

		retVal.To = val.To

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseTransfer not implemented (tag=%s)", merged.currTag)
	return
}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *zktoro020.ZktoroUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *zktoro020.ZktoroUpgraded, implementation []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroUpgraded is a merged return type.
type ZktoroUpgraded struct {
	Implementation common.Address

	Raw types.Log
}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroFilterer) ParseUpgraded(log types.Log) (retVal *ZktoroUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroUpgraded{}

	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}
