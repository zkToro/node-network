// Code generated by go-merge-types. DO NOT EDIT.

package contract_zktoro_staking

import (
	import_fmt "fmt"
	import_sync "sync"

	zktorostaking011 "zktoro/zktoro-core-go/contracts/generated/contract_zktoro_staking_0_1_1"

	zktorostaking012 "zktoro/zktoro-core-go/contracts/generated/contract_zktoro_staking_0_1_2"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"math/big"

	"github.com/ethereum/go-ethereum/common"
)

// ZktoroStakingCaller is a new type which can multiplex calls to different implementation types.
type ZktoroStakingCaller struct {
	typ0 *zktorostaking011.ZktoroStakingCaller

	typ1 *zktorostaking012.ZktoroStakingCaller

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewZktoroStakingCaller creates a new merged type.
func NewZktoroStakingCaller(address common.Address, caller bind.ContractCaller) (*ZktoroStakingCaller, error) {
	var (
		mergedType ZktoroStakingCaller
		err        error
	)
	mergedType.currTag = "0.1.2"

	mergedType.typ0, err = zktorostaking011.NewZktoroStakingCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize zktorostaking011.ZktoroStakingCaller: %v", err)
	}

	mergedType.typ1, err = zktorostaking012.NewZktoroStakingCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize zktorostaking012.ZktoroStakingCaller: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForZktoroStakingCaller tells if given tag is a known tag.
func IsKnownTagForZktoroStakingCaller(tag string) bool {

	if tag == "0.1.1" {
		return true
	}

	if tag == "0.1.2" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ZktoroStakingCaller) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForZktoroStakingCaller(tag) {
		tag = "0.1.2"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ZktoroStakingCaller) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ZktoroStakingCaller) Safe() {
	merged.unsafe = false
}

// ActiveSharesToStake multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) ActiveSharesToStake(opts *bind.CallOpts, activeSharesId *big.Int, amount *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ActiveSharesToStake(opts, activeSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ActiveSharesToStake(opts, activeSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.ActiveSharesToStake not implemented (tag=%s)", merged.currTag)
	return
}

// ActiveStakeFor multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) ActiveStakeFor(opts *bind.CallOpts, subjectType uint8, subject *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ActiveStakeFor(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ActiveStakeFor(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.ActiveStakeFor not implemented (tag=%s)", merged.currTag)
	return
}

// AvailableReward multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) AvailableReward(opts *bind.CallOpts, subjectType uint8, subject *big.Int, account common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.AvailableReward(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.AvailableReward not implemented (tag=%s)", merged.currTag)
	return
}

// BalanceOf multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) BalanceOf(opts *bind.CallOpts, account common.Address, id *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.BalanceOf(opts, account, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.BalanceOf(opts, account, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.BalanceOf not implemented (tag=%s)", merged.currTag)
	return
}

// BalanceOfBatch multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) BalanceOfBatch(opts *bind.CallOpts, accounts []common.Address, ids []*big.Int) (retVal []*big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.BalanceOfBatch(opts, accounts, ids)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.BalanceOfBatch(opts, accounts, ids)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.BalanceOfBatch not implemented (tag=%s)", merged.currTag)
	return
}

// Exists multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) Exists(opts *bind.CallOpts, id *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.Exists(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.Exists(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.Exists not implemented (tag=%s)", merged.currTag)
	return
}

// InactiveSharesOf multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) InactiveSharesOf(opts *bind.CallOpts, subjectType uint8, subject *big.Int, account common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.InactiveSharesOf(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.InactiveSharesOf(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.InactiveSharesOf not implemented (tag=%s)", merged.currTag)
	return
}

// InactiveSharesToStake multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) InactiveSharesToStake(opts *bind.CallOpts, inactiveSharesId *big.Int, amount *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.InactiveSharesToStake(opts, inactiveSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.InactiveSharesToStake(opts, inactiveSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.InactiveSharesToStake not implemented (tag=%s)", merged.currTag)
	return
}

// InactiveStakeFor multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) InactiveStakeFor(opts *bind.CallOpts, subjectType uint8, subject *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.InactiveStakeFor(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.InactiveStakeFor(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.InactiveStakeFor not implemented (tag=%s)", merged.currTag)
	return
}

// IsApprovedForAll multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) IsApprovedForAll(opts *bind.CallOpts, account common.Address, operator common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.IsApprovedForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.IsApprovedForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.IsApprovedForAll not implemented (tag=%s)", merged.currTag)
	return
}

// IsFrozen multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) IsFrozen(opts *bind.CallOpts, subjectType uint8, subject *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.IsFrozen(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.IsFrozen(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.IsFrozen not implemented (tag=%s)", merged.currTag)
	return
}

// IsTrustedForwarder multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) IsTrustedForwarder(opts *bind.CallOpts, forwarder common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.IsTrustedForwarder not implemented (tag=%s)", merged.currTag)
	return
}

// ProxiableUUID multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) ProxiableUUID(opts *bind.CallOpts) (retVal [32]byte, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.ProxiableUUID not implemented (tag=%s)", merged.currTag)
	return
}

// SharesOf multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) SharesOf(opts *bind.CallOpts, subjectType uint8, subject *big.Int, account common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.SharesOf(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.SharesOf(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.SharesOf not implemented (tag=%s)", merged.currTag)
	return
}

// StakeToActiveShares multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) StakeToActiveShares(opts *bind.CallOpts, activeSharesId *big.Int, amount *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.StakeToActiveShares(opts, activeSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.StakeToActiveShares(opts, activeSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.StakeToActiveShares not implemented (tag=%s)", merged.currTag)
	return
}

// StakeToInactiveShares multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) StakeToInactiveShares(opts *bind.CallOpts, inactiveSharesId *big.Int, amount *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.StakeToInactiveShares(opts, inactiveSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.StakeToInactiveShares(opts, inactiveSharesId, amount)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.StakeToInactiveShares not implemented (tag=%s)", merged.currTag)
	return
}

// StakedToken multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) StakedToken(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.StakedToken(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.StakedToken(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.StakedToken not implemented (tag=%s)", merged.currTag)
	return
}

// SupportsInterface multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.SupportsInterface not implemented (tag=%s)", merged.currTag)
	return
}

// TotalActiveStake multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) TotalActiveStake(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.TotalActiveStake(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.TotalActiveStake(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.TotalActiveStake not implemented (tag=%s)", merged.currTag)
	return
}

// TotalInactiveShares multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) TotalInactiveShares(opts *bind.CallOpts, subjectType uint8, subject *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.TotalInactiveShares(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.TotalInactiveShares(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.TotalInactiveShares not implemented (tag=%s)", merged.currTag)
	return
}

// TotalInactiveStake multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) TotalInactiveStake(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.TotalInactiveStake(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.TotalInactiveStake(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.TotalInactiveStake not implemented (tag=%s)", merged.currTag)
	return
}

// TotalShares multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) TotalShares(opts *bind.CallOpts, subjectType uint8, subject *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.TotalShares(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.TotalShares(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.TotalShares not implemented (tag=%s)", merged.currTag)
	return
}

// TotalSupply multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) TotalSupply(opts *bind.CallOpts, id *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.TotalSupply(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.TotalSupply(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.TotalSupply not implemented (tag=%s)", merged.currTag)
	return
}

// Treasury multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) Treasury(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.Treasury(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.Treasury(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.Treasury not implemented (tag=%s)", merged.currTag)
	return
}

// Uri multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) Uri(opts *bind.CallOpts, arg0 *big.Int) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.Uri(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.Uri(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.Uri not implemented (tag=%s)", merged.currTag)
	return
}

// Version multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) Version(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.Version not implemented (tag=%s)", merged.currTag)
	return
}

// MAXSLASHABLEPERCENT multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) MAXSLASHABLEPERCENT(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.MAXSLASHABLEPERCENT(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.MAXSLASHABLEPERCENT not implemented (tag=%s)", merged.currTag)
	return
}

// MAXWITHDRAWALDELAY multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) MAXWITHDRAWALDELAY(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.MAXWITHDRAWALDELAY(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.MAXWITHDRAWALDELAY not implemented (tag=%s)", merged.currTag)
	return
}

// MINWITHDRAWALDELAY multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) MINWITHDRAWALDELAY(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.MINWITHDRAWALDELAY(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.MINWITHDRAWALDELAY not implemented (tag=%s)", merged.currTag)
	return
}

// Allocator multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) Allocator(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.Allocator(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.Allocator not implemented (tag=%s)", merged.currTag)
	return
}

// GetDelegatedSubjectType multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) GetDelegatedSubjectType(opts *bind.CallOpts, subjectType uint8) (retVal uint8, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.GetDelegatedSubjectType(opts, subjectType)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.GetDelegatedSubjectType not implemented (tag=%s)", merged.currTag)
	return
}

// GetDelegatorSubjectType multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) GetDelegatorSubjectType(opts *bind.CallOpts, subjectType uint8) (retVal uint8, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.GetDelegatorSubjectType(opts, subjectType)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.GetDelegatorSubjectType not implemented (tag=%s)", merged.currTag)
	return
}

// GetSubjectTypeAgency multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) GetSubjectTypeAgency(opts *bind.CallOpts, subjectType uint8) (retVal uint8, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.GetSubjectTypeAgency(opts, subjectType)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.GetSubjectTypeAgency not implemented (tag=%s)", merged.currTag)
	return
}

// OpenProposals multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) OpenProposals(opts *bind.CallOpts, arg0 *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.OpenProposals(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.OpenProposals not implemented (tag=%s)", merged.currTag)
	return
}

// SlashDelegatorsPercent multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) SlashDelegatorsPercent(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.SlashDelegatorsPercent(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.SlashDelegatorsPercent not implemented (tag=%s)", merged.currTag)
	return
}

// SubjectGateway multiplexes to different implementations of the method.
func (merged *ZktoroStakingCaller) SubjectGateway(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.SubjectGateway(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingCaller.SubjectGateway not implemented (tag=%s)", merged.currTag)
	return
}
