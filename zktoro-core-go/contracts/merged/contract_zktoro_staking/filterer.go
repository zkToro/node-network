// Code generated by go-merge-types. DO NOT EDIT.

package contract_zktoro_staking

import (
	import_fmt "fmt"
	import_sync "sync"

	zktorostaking011 "zktoro/zktoro-core-go/contracts/generated/contract_zktoro_staking_0_1_1"

	zktorostaking012 "zktoro/zktoro-core-go/contracts/generated/contract_zktoro_staking_0_1_2"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"
)

// ZktoroStakingFilterer is a new type which can multiplex calls to different implementation types.
type ZktoroStakingFilterer struct {
	typ0 *zktorostaking011.ZktoroStakingFilterer

	typ1 *zktorostaking012.ZktoroStakingFilterer

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewZktoroStakingFilterer creates a new merged type.
func NewZktoroStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*ZktoroStakingFilterer, error) {
	var (
		mergedType ZktoroStakingFilterer
		err        error
	)
	mergedType.currTag = "0.1.2"

	mergedType.typ0, err = zktorostaking011.NewZktoroStakingFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize zktorostaking011.ZktoroStakingFilterer: %v", err)
	}

	mergedType.typ1, err = zktorostaking012.NewZktoroStakingFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize zktorostaking012.ZktoroStakingFilterer: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForZktoroStakingFilterer tells if given tag is a known tag.
func IsKnownTagForZktoroStakingFilterer(tag string) bool {

	if tag == "0.1.1" {
		return true
	}

	if tag == "0.1.2" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ZktoroStakingFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForZktoroStakingFilterer(tag) {
		tag = "0.1.2"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ZktoroStakingFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ZktoroStakingFilterer) Safe() {
	merged.unsafe = false
}

// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingAccessManagerUpdatedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingAccessManagerUpdatedIterator
}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterAccessManagerUpdatedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *zktorostaking012.ZktoroStakingAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingAccessManagerUpdated is a merged return type.
type ZktoroStakingAccessManagerUpdated struct {
	NewAddressManager common.Address

	Raw types.Log
}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *ZktoroStakingAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingAccessManagerUpdated{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingAdminChangedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingAdminChangedIterator
}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterAdminChangedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingAdminChanged, sinkAlt2 chan<- *zktorostaking012.ZktoroStakingAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingAdminChanged is a merged return type.
type ZktoroStakingAdminChanged struct {
	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log
}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseAdminChanged(log types.Log) (retVal *ZktoroStakingAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingAdminChanged{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterApprovalForAllOutput is a merged return type.
type FilterApprovalForAllOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingApprovalForAllIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingApprovalForAllIterator
}

// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (retVal *FilterApprovalForAllOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterApprovalForAllOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterApprovalForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterApprovalForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingApprovalForAll, account []common.Address, operator []common.Address, sinkAlt3 chan<- *zktorostaking012.ZktoroStakingApprovalForAll) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchApprovalForAll(opts, sinkAlt3, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingApprovalForAll is a merged return type.
type ZktoroStakingApprovalForAll struct {
	Account common.Address

	Operator common.Address

	Approved bool

	Raw types.Log
}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseApprovalForAll(log types.Log) (retVal *ZktoroStakingApprovalForAll, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingApprovalForAll{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Account = val.Account

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Account = val.Account

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingBeaconUpgradedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingBeaconUpgradedIterator
}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterBeaconUpgradedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingBeaconUpgraded, beacon []common.Address, sinkAlt4 chan<- *zktorostaking012.ZktoroStakingBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt4, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingBeaconUpgraded is a merged return type.
type ZktoroStakingBeaconUpgraded struct {
	Beacon common.Address

	Raw types.Log
}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseBeaconUpgraded(log types.Log) (retVal *ZktoroStakingBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingBeaconUpgraded{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDelaySetOutput is a merged return type.
type FilterDelaySetOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingDelaySetIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingDelaySetIterator
}

// FilterDelaySet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterDelaySet(opts *bind.FilterOpts) (retVal *FilterDelaySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterDelaySetOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterDelaySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterDelaySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterDelaySet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDelaySet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchDelaySet(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingDelaySet, sinkAlt5 chan<- *zktorostaking012.ZktoroStakingDelaySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchDelaySet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchDelaySet(opts, sinkAlt5)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchDelaySet not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingDelaySet is a merged return type.
type ZktoroStakingDelaySet struct {
	NewWithdrawalDelay *big.Int

	Raw types.Log
}

// ParseDelaySet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseDelaySet(log types.Log) (retVal *ZktoroStakingDelaySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingDelaySet{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseDelaySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewWithdrawalDelay = val.NewWithdrawalDelay

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseDelaySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewWithdrawalDelay = val.NewWithdrawalDelay

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseDelaySet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterFrozeOutput is a merged return type.
type FilterFrozeOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingFrozeIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingFrozeIterator
}

// FilterFroze multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterFroze(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterFrozeOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterFrozeOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterFroze(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterFroze(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterFroze not implemented (tag=%s)", merged.currTag)
	return
}

// WatchFroze multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchFroze(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingFroze, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt6 chan<- *zktorostaking012.ZktoroStakingFroze) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchFroze(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchFroze(opts, sinkAlt6, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchFroze not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingFroze is a merged return type.
type ZktoroStakingFroze struct {
	SubjectType uint8

	Subject *big.Int

	By common.Address

	IsFrozen bool

	Raw types.Log
}

// ParseFroze multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseFroze(log types.Log) (retVal *ZktoroStakingFroze, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingFroze{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseFroze(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.IsFrozen = val.IsFrozen

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseFroze(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.IsFrozen = val.IsFrozen

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseFroze not implemented (tag=%s)", merged.currTag)
	return
}

// FilterInitializedOutput is a merged return type.
type FilterInitializedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingInitializedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingInitializedIterator
}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *FilterInitializedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterInitializedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// WatchInitialized multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingInitialized, sinkAlt7 chan<- *zktorostaking012.ZktoroStakingInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchInitialized(opts, sinkAlt7)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingInitialized is a merged return type.
type ZktoroStakingInitialized struct {
	Version uint8

	Raw types.Log
}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseInitialized(log types.Log) (retVal *ZktoroStakingInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingInitialized{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// FilterMaxStakeReachedOutput is a merged return type.
type FilterMaxStakeReachedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingMaxStakeReachedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingMaxStakeReachedIterator
}

// FilterMaxStakeReached multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterMaxStakeReached(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *FilterMaxStakeReachedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterMaxStakeReachedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterMaxStakeReached(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterMaxStakeReached(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}

// WatchMaxStakeReached multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchMaxStakeReached(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingMaxStakeReached, subjectType []uint8, subject []*big.Int, sinkAlt8 chan<- *zktorostaking012.ZktoroStakingMaxStakeReached) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchMaxStakeReached(opts, sink, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchMaxStakeReached(opts, sinkAlt8, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingMaxStakeReached is a merged return type.
type ZktoroStakingMaxStakeReached struct {
	SubjectType uint8

	Subject *big.Int

	Raw types.Log
}

// ParseMaxStakeReached multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseMaxStakeReached(log types.Log) (retVal *ZktoroStakingMaxStakeReached, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingMaxStakeReached{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseMaxStakeReached(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseMaxStakeReached(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}

// FilterReleased multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterReleased(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal *zktorostaking011.ZktoroStakingReleasedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterReleased(opts, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterReleased not implemented (tag=%s)", merged.currTag)
	return
}

// WatchReleased multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchReleased(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingReleased, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchReleased(opts, sink, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchReleased not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingReleased is a merged return type.
type ZktoroStakingReleased struct {
	SubjectType uint8

	Subject *big.Int

	To common.Address

	Value *big.Int

	Raw types.Log
}

// ParseReleased multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseReleased(log types.Log) (retVal *ZktoroStakingReleased, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingReleased{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseReleased(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.To = val.To

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseReleased not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRewarded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterRewarded(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, from []common.Address) (retVal *zktorostaking011.ZktoroStakingRewardedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterRewarded(opts, subjectType, subject, from)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRewarded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchRewarded(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingRewarded, subjectType []uint8, subject []*big.Int, from []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchRewarded(opts, sink, subjectType, subject, from)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingRewarded is a merged return type.
type ZktoroStakingRewarded struct {
	SubjectType uint8

	Subject *big.Int

	From common.Address

	Value *big.Int

	Raw types.Log
}

// ParseRewarded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseRewarded(log types.Log) (retVal *ZktoroStakingRewarded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingRewarded{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseRewarded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.From = val.From

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingRouterUpdatedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingRouterUpdatedIterator
}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterRouterUpdatedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingRouterUpdated, router []common.Address, sinkAlt9 chan<- *zktorostaking012.ZktoroStakingRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt9, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingRouterUpdated is a merged return type.
type ZktoroStakingRouterUpdated struct {
	Router common.Address

	Raw types.Log
}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseRouterUpdated(log types.Log) (retVal *ZktoroStakingRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingRouterUpdated{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSlashedOutput is a merged return type.
type FilterSlashedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingSlashedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingSlashedIterator
}

// FilterSlashed multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterSlashed(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterSlashedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterSlashedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterSlashed(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashed(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterSlashed not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSlashed multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchSlashed(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingSlashed, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt10 chan<- *zktorostaking012.ZktoroStakingSlashed) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchSlashed(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashed(opts, sinkAlt10, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchSlashed not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingSlashed is a merged return type.
type ZktoroStakingSlashed struct {
	SubjectType uint8

	Subject *big.Int

	By common.Address

	Value *big.Int

	Raw types.Log
}

// ParseSlashed multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseSlashed(log types.Log) (retVal *ZktoroStakingSlashed, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingSlashed{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseSlashed(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashed(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseSlashed not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSlashedShareSentOutput is a merged return type.
type FilterSlashedShareSentOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingSlashedShareSentIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingSlashedShareSentIterator
}

// FilterSlashedShareSent multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterSlashedShareSent(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterSlashedShareSentOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterSlashedShareSentOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterSlashedShareSent(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashedShareSent(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSlashedShareSent multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchSlashedShareSent(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingSlashedShareSent, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt11 chan<- *zktorostaking012.ZktoroStakingSlashedShareSent) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchSlashedShareSent(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashedShareSent(opts, sinkAlt11, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingSlashedShareSent is a merged return type.
type ZktoroStakingSlashedShareSent struct {
	SubjectType uint8

	Subject *big.Int

	By common.Address

	Value *big.Int

	Raw types.Log
}

// ParseSlashedShareSent multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseSlashedShareSent(log types.Log) (retVal *ZktoroStakingSlashedShareSent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingSlashedShareSent{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseSlashedShareSent(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashedShareSent(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeDepositedOutput is a merged return type.
type FilterStakeDepositedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingStakeDepositedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingStakeDepositedIterator
}

// FilterStakeDeposited multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterStakeDeposited(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterStakeDepositedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterStakeDepositedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterStakeDeposited(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterStakeDeposited(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeDeposited multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchStakeDeposited(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingStakeDeposited, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt12 chan<- *zktorostaking012.ZktoroStakingStakeDeposited) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchStakeDeposited(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchStakeDeposited(opts, sinkAlt12, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingStakeDeposited is a merged return type.
type ZktoroStakingStakeDeposited struct {
	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Amount *big.Int

	Raw types.Log
}

// ParseStakeDeposited multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseStakeDeposited(log types.Log) (retVal *ZktoroStakingStakeDeposited, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingStakeDeposited{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseStakeDeposited(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseStakeDeposited(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterStakeParamsManagerSet(opts *bind.FilterOpts, newManager []common.Address) (retVal *zktorostaking011.ZktoroStakingStakeParamsManagerSetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterStakeParamsManagerSet(opts, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchStakeParamsManagerSet(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingStakeParamsManagerSet, newManager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchStakeParamsManagerSet(opts, sink, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingStakeParamsManagerSet is a merged return type.
type ZktoroStakingStakeParamsManagerSet struct {
	NewManager common.Address

	Raw types.Log
}

// ParseStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseStakeParamsManagerSet(log types.Log) (retVal *ZktoroStakingStakeParamsManagerSet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingStakeParamsManagerSet{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseStakeParamsManagerSet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewManager = val.NewManager

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTokensSweptOutput is a merged return type.
type FilterTokensSweptOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingTokensSweptIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingTokensSweptIterator
}

// FilterTokensSwept multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterTokensSwept(opts *bind.FilterOpts, token []common.Address) (retVal *FilterTokensSweptOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTokensSweptOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTokensSwept multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchTokensSwept(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingTokensSwept, token []common.Address, sinkAlt13 chan<- *zktorostaking012.ZktoroStakingTokensSwept) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTokensSwept(opts, sink, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTokensSwept(opts, sinkAlt13, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingTokensSwept is a merged return type.
type ZktoroStakingTokensSwept struct {
	Token common.Address

	To common.Address

	Amount *big.Int

	Raw types.Log
}

// ParseTokensSwept multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseTokensSwept(log types.Log) (retVal *ZktoroStakingTokensSwept, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingTokensSwept{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTransferBatchOutput is a merged return type.
type FilterTransferBatchOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingTransferBatchIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingTransferBatchIterator
}

// FilterTransferBatch multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (retVal *FilterTransferBatchOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTransferBatchOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTransferBatch(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTransferBatch(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTransferBatch multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingTransferBatch, operator []common.Address, from []common.Address, to []common.Address, sinkAlt14 chan<- *zktorostaking012.ZktoroStakingTransferBatch) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTransferBatch(opts, sink, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTransferBatch(opts, sinkAlt14, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingTransferBatch is a merged return type.
type ZktoroStakingTransferBatch struct {
	Operator common.Address

	From common.Address

	To common.Address

	Ids []*big.Int

	Values []*big.Int

	Raw types.Log
}

// ParseTransferBatch multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseTransferBatch(log types.Log) (retVal *ZktoroStakingTransferBatch, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingTransferBatch{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTransferBatch(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Ids = val.Ids

		retVal.Values = val.Values

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTransferBatch(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Ids = val.Ids

		retVal.Values = val.Values

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTransferSingleOutput is a merged return type.
type FilterTransferSingleOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingTransferSingleIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingTransferSingleIterator
}

// FilterTransferSingle multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (retVal *FilterTransferSingleOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTransferSingleOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTransferSingle(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTransferSingle(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTransferSingle multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingTransferSingle, operator []common.Address, from []common.Address, to []common.Address, sinkAlt15 chan<- *zktorostaking012.ZktoroStakingTransferSingle) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTransferSingle(opts, sink, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTransferSingle(opts, sinkAlt15, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingTransferSingle is a merged return type.
type ZktoroStakingTransferSingle struct {
	Operator common.Address

	From common.Address

	To common.Address

	Id *big.Int

	Value *big.Int

	Raw types.Log
}

// ParseTransferSingle multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseTransferSingle(log types.Log) (retVal *ZktoroStakingTransferSingle, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingTransferSingle{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTransferSingle(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Id = val.Id

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTransferSingle(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Id = val.Id

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTreasurySetOutput is a merged return type.
type FilterTreasurySetOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingTreasurySetIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingTreasurySetIterator
}

// FilterTreasurySet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterTreasurySet(opts *bind.FilterOpts) (retVal *FilterTreasurySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTreasurySetOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTreasurySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTreasurySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTreasurySet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchTreasurySet(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingTreasurySet, sinkAlt16 chan<- *zktorostaking012.ZktoroStakingTreasurySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTreasurySet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTreasurySet(opts, sinkAlt16)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingTreasurySet is a merged return type.
type ZktoroStakingTreasurySet struct {
	NewTreasury common.Address

	Raw types.Log
}

// ParseTreasurySet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseTreasurySet(log types.Log) (retVal *ZktoroStakingTreasurySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingTreasurySet{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTreasurySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewTreasury = val.NewTreasury

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTreasurySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewTreasury = val.NewTreasury

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterURIOutput is a merged return type.
type FilterURIOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingURIIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingURIIterator
}

// FilterURI multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (retVal *FilterURIOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterURIOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterURI(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterURI(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterURI not implemented (tag=%s)", merged.currTag)
	return
}

// WatchURI multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchURI(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingURI, id []*big.Int, sinkAlt17 chan<- *zktorostaking012.ZktoroStakingURI) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchURI(opts, sink, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchURI(opts, sinkAlt17, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchURI not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingURI is a merged return type.
type ZktoroStakingURI struct {
	Value string

	Id *big.Int

	Raw types.Log
}

// ParseURI multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseURI(log types.Log) (retVal *ZktoroStakingURI, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingURI{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseURI(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Value = val.Value

		retVal.Id = val.Id

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseURI(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Value = val.Value

		retVal.Id = val.Id

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseURI not implemented (tag=%s)", merged.currTag)
	return
}

// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingUpgradedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingUpgradedIterator
}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterUpgradedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingUpgraded, implementation []common.Address, sinkAlt18 chan<- *zktorostaking012.ZktoroStakingUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt18, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingUpgraded is a merged return type.
type ZktoroStakingUpgraded struct {
	Implementation common.Address

	Raw types.Log
}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseUpgraded(log types.Log) (retVal *ZktoroStakingUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingUpgraded{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterWithdrawalExecutedOutput is a merged return type.
type FilterWithdrawalExecutedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingWithdrawalExecutedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingWithdrawalExecutedIterator
}

// FilterWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterWithdrawalExecuted(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterWithdrawalExecutedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterWithdrawalExecutedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterWithdrawalExecuted(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterWithdrawalExecuted(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}

// WatchWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchWithdrawalExecuted(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingWithdrawalExecuted, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt19 chan<- *zktorostaking012.ZktoroStakingWithdrawalExecuted) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchWithdrawalExecuted(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchWithdrawalExecuted(opts, sinkAlt19, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingWithdrawalExecuted is a merged return type.
type ZktoroStakingWithdrawalExecuted struct {
	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Raw types.Log
}

// ParseWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseWithdrawalExecuted(log types.Log) (retVal *ZktoroStakingWithdrawalExecuted, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingWithdrawalExecuted{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseWithdrawalExecuted(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseWithdrawalExecuted(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}

// FilterWithdrawalInitiatedOutput is a merged return type.
type FilterWithdrawalInitiatedOutput struct {
	Zktorostaking011Result *zktorostaking011.ZktoroStakingWithdrawalInitiatedIterator

	Zktorostaking012Result *zktorostaking012.ZktoroStakingWithdrawalInitiatedIterator
}

// FilterWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterWithdrawalInitiated(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterWithdrawalInitiatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterWithdrawalInitiatedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterWithdrawalInitiated(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterWithdrawalInitiated(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Zktorostaking012Result = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchWithdrawalInitiated(opts *bind.WatchOpts, sink chan<- *zktorostaking011.ZktoroStakingWithdrawalInitiated, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt20 chan<- *zktorostaking012.ZktoroStakingWithdrawalInitiated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchWithdrawalInitiated(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchWithdrawalInitiated(opts, sinkAlt20, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingWithdrawalInitiated is a merged return type.
type ZktoroStakingWithdrawalInitiated struct {
	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Deadline uint64

	Raw types.Log
}

// ParseWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseWithdrawalInitiated(log types.Log) (retVal *ZktoroStakingWithdrawalInitiated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingWithdrawalInitiated{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseWithdrawalInitiated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Deadline = val.Deadline

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseWithdrawalInitiated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Deadline = val.Deadline

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterSlashDelegatorsPercentSet(opts *bind.FilterOpts) (retVal *zktorostaking012.ZktoroStakingSlashDelegatorsPercentSetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashDelegatorsPercentSet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchSlashDelegatorsPercentSet(opts *bind.WatchOpts, sink chan<- *zktorostaking012.ZktoroStakingSlashDelegatorsPercentSet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashDelegatorsPercentSet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingSlashDelegatorsPercentSet is a merged return type.
type ZktoroStakingSlashDelegatorsPercentSet struct {
	Percent *big.Int

	Raw types.Log
}

// ParseSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseSlashDelegatorsPercentSet(log types.Log) (retVal *ZktoroStakingSlashDelegatorsPercentSet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingSlashDelegatorsPercentSet{}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashDelegatorsPercentSet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Percent = val.Percent

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) FilterStakeHelpersConfigured(opts *bind.FilterOpts, subjectGateway []common.Address, allocator []common.Address) (retVal *zktorostaking012.ZktoroStakingStakeHelpersConfiguredIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterStakeHelpersConfigured(opts, subjectGateway, allocator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.FilterStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) WatchStakeHelpersConfigured(opts *bind.WatchOpts, sink chan<- *zktorostaking012.ZktoroStakingStakeHelpersConfigured, subjectGateway []common.Address, allocator []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchStakeHelpersConfigured(opts, sink, subjectGateway, allocator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.WatchStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}

// ZktoroStakingStakeHelpersConfigured is a merged return type.
type ZktoroStakingStakeHelpersConfigured struct {
	SubjectGateway common.Address

	Allocator common.Address

	Raw types.Log
}

// ParseStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *ZktoroStakingFilterer) ParseStakeHelpersConfigured(log types.Log) (retVal *ZktoroStakingStakeHelpersConfigured, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ZktoroStakingStakeHelpersConfigured{}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseStakeHelpersConfigured(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectGateway = val.SubjectGateway

		retVal.Allocator = val.Allocator

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ZktoroStakingFilterer.ParseStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}
